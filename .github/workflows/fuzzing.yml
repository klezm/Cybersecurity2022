name: fuzzing
on:
  # permit manual invocation of the workflow via the GitHub Actions web UI
  workflow_dispatch:
    inputs:
      submodule:
        type: choice
        description: 'Submodule to fuzz'
        required: false
        default: 'rpki-rs'
        options: ['rpki-rs', 'krill', 'routinator']
      fuzz:
        type: string
        description: 'Fuzz-arg: Fuzzing target'
        required: false
        # default: 'fuzz_target_1'
        default: 'fuzz_target_rrdp'
      max_total_time:
        type: string
        # https://docs.github.com/en/actions/learn-github-actions/usage-limits-billing-and-administration
        description: 'Fuzz-arg: Maximum total time in seconds. (Each job in a workflow can run for up to 6 hours of execution time.)'
        required: false
        default: '19800'
      seed:
        type: string
        description: 'Fuzz-arg: Seed'
        required: false
        default: '0'
      only_ascii:
        type: boolean
        description: 'Fuzz-arg: Only ASCII'
        required: false
        default: true
      corpus:
        type: string
        description: 'Fuzz-arg: paths to corpus files'
        required: false
        # default: '../corpus/xml/all/*'
        default: '../corpus/xml/snapshot/*'
      fuzz_args:
        type: string
        description: 'Fuzz-arg: Additional arguments to pass to the fuzzer'
        required: false
        default: '--locked'
      artifacts_up_down_load:
        type: choice
        description: 'Upload and download artifacts'
        required: false
        default: 'upload_and_download'
        options: ['upload', 'download', 'download_and_upload', 'none']
      # resume_with_artifacts:
      #   type: boolean
      #   description: 'Resume fuzzing with artifacts from previous run, including corpus, artifacts and coverage'
      #   required: false
      #   default: true
      # upload_artifacts:
      #   type: boolean
      #   description: 'Upload Artifacts'
      #   required: false
      #   default: true
      rust_toolchain:
        type: string
        description: 'Rust toolchain'
        required: false
        default: 'nightly'
        # options: ['nightly', 'stable', 'beta', '1.56.1']
      verbose:
        type: boolean
        description: 'Verbose output'
        required: false
        default: false
  # schedule:
  #   - cron: '0 */6 * * *' # run every 6 hours
  #   - cron: '0 0 * * *' # run daily at midnight

env:
  ARTIFACT_DOWNLOAD: ${{ contains(github.event.inputs.artifacts_up_down_load, 'download') }}
  ARTIFACT_UPLOAD: ${{ contains(github.event.inputs.artifacts_up_down_load, 'upload') }}
  # TODO: fromJSON()
  # ARG_BUILD: fromJSON()

jobs:
  fuzz:
    name: fuzz
    runs-on: ubuntu-latest
    # runs-on: ${{ matrix.os }}
    # continue-on-error: true
    # permissions:
    #   # actions: read|write|none
    #   # checks: read|write|none
    #   contents: read
    #   # deployments: read|write|none
    #   # id-token: read|write|none
    #   issues: write
    #   # discussions: read|write|none
    #   # packages: read|write|none
    #   # pages: write
    #   # pull-requests: read|write|none
    #   # repository-projects: read|write|none
    #   # security-events: read|write|none
    #   # statuses: read|write|none
    #   # Actions: write
    #   # Checks: write
    #   # Contents: write
    #   # Deployments: write
    #   # Discussions: write
    #   # Issues: write
    #   # Metadata: read
    #   # Packages: write
    #   # Pages: write
    #   # PullRequests: write
    #   # RepositoryProjects: write
    #   # SecurityEvents: write
    #   # Statuses: write
    defaults:
      run:
        working-directory: ${{ github.event.inputs.submodule }}
    # strategy:
    #   matrix:
    #     tag: ["v0.15.9", "v0.15.8"]
    #     # os: [ubuntu-latest, windows-latest, macOS-latest]
    #     # rust: [1.56.1, stable, beta, nightly]
    steps:
    - name: Checkout repository
      uses: actions/checkout@v1
      with:
        submodules: true

    - name: Fuzz Demo Setup
      if: ${{ github.event.inputs.submodule == 'humantime' }}
      working-directory: .
      run: |
        git clone --depth 1 https://github.com/tailhook/humantime

    - name: Restore submodules
      working-directory: .
      run: |
        # echo "pwd: $(pwd)"
        # ls -lha

        # echo "::group::Resetting submodules"
        # # When running the action locally with act git reset & git clean might be required
        # # (cd ..; git submodule -q foreach pwd | xargs -t -I % -n 1 git -C % reset --hard)
        # find . -name .git -print | xargs -t -I % git -C %/.. reset --hard
        # find . -name .git -print | xargs -t -I % git -C %/.. clean -fxd
        # echo "::endgroup::"

        echo "::group::Restoring submodules"
        .devcontainer/scripts/submodules-backup-restore.sh restore
        echo "::endgroup::"

        echo "::group::Make Corpus"
        scripts/make-corpus.sh
        echo "::endgroup::"

    - name: playground 1
      id: playground1
      # if: ${{ github.event.inputs.submodule == 'rpki-rs' }}
      # if: ${{ github.event.inputs.verbose == 'true' }}
      run: |
        echo "::group::GitHub Acction Context"
        echo -e "\ngithub.event.inputs.<...>"
        # echo "${{ github.event.inputs.submodule }} - ${{ github.event.inputs.fuzz }} - ${{ github.event.inputs.max_total_time }} - ${{ github.event.inputs.resume_with_artifacts }}"
        echo "submodule:              ${{ github.event.inputs.submodule }}"
        echo "fuzz:                   ${{ github.event.inputs.fuzz }}"
        echo "max_total_time:         ${{ github.event.inputs.max_total_time }}"
        echo "seed:                   ${{ github.event.inputs.seed }}"
        echo "only_ascii:             ${{ github.event.inputs.only_ascii }}"
        echo "corpus:                 ${{ github.event.inputs.corpus }}"
        echo "fuzz_args:              ${{ github.event.inputs.fuzz_args }}"
        echo "artifacts_up_down_load: ${{ github.event.inputs.artifacts_up_down_load }}"
        echo "rust_toolchain:         ${{ github.event.inputs.rust_toolchain }}"
        echo "verbose:                ${{ github.event.inputs.verbose }}"
        echo "ARTIFACT_DOWNLOAD:      ${{ env.ARTIFACT_DOWNLOAD }}"
        echo "ARTIFACT_UPLOAD:        ${{ env.ARTIFACT_UPLOAD }}"
        echo "::endgroup::"
        echo -e "\npwd: $(pwd)"

        # echo "::group::List files ../"
        # find .. -print | sed -e "s;[^/]*/;|____;g;s;____|;  |;g"
        # echo "::endgroup::"
        # echo -e "\n\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n"

        echo "::group::List files"
        # ls -aR . | grep ':$' | sed -e 's/:$//' -e 's/[^\/]*\//|  /g' -e 's/|  \([^|]\)/|–– \1/g'
        ls -R .. | grep ':$' | sed -e 's/:$//' -e 's/[^\/]*\//|  /g' -e 's/|  \([^|]\)/|–– \1/g'
        echo "::endgroup::"

        echo "::group::env"
        env | sort
        echo "::endgroup::"

    - name: playground 2
      # if: ${{ env.ARTIFACT_DOWNLOAD == 'true' }}
      # if: ${{ steps.playground1.conclusion.0 }}
      # if: ${{ steps.playground1.conclusion }}
      # if: ${{ steps.playground1.outcome }}
      # if: ${{ steps.playground1.outcome }}
      # if: ${{ steps.playground1.outputs }}
      run: |
        echo "playground 2"

        echo "::group::Step Playground 1 Context"
        echo "conclusion:     ${{ steps.playground1.conclusion }}"
        echo "outcome:        ${{ steps.playground1.outcome }}"
        echo "outputs:        ${{ steps.playground1.outputs }}"
        echo "outputs.stdout: ${{ steps.playground1.outputs.stdout }}"
        echo "::endgroup::"

    - name: playground 3
      if: ${{ env.ARTIFACT_UPLOAD == 'true' }}
      run: |
        echo -e "\n\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n"
        echo "playground 3"
        echo -e "\n\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n"

    - name: install dependencies
      run: |
        echo "::group::apt"
        sudo apt update
        sudo apt install -y \
          ca-certificates gnupg lsb-release \
          curl wget git gcc rsync build-essential \
          pkg-config libssl-dev openssl \
          expect colorized-logs
        echo "::endgroup::"

    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
          # toolchain: nightly
          toolchain: ${{ github.event.inputs.rust_toolchain }}
          # override: true
          components: rust-src
          # components: rust-src, rustfmt, clippy
      # uses: hecrj/setup-rust-action@v1
      # with:
      #   # rust-version: ${{ matrix.rust }}
      #   rust-version: nightly
      #   components: rust-src
      #   # components: rust-src, rust-analyzer, clippy, rustfmt
      #   # targets: x86_64-unknown-linux-gnu
      # run: |
    # - uses: actions-rs/install@v0.1
    #   with:
    #     crate: cargo-fuzz
    #     version: latest
    #     use-tool-cache: true

    - name: Install cargo fuzz
      run: |
        echo "::group::rustup install nightly"
        rustup install nightly
        echo "::endgroup::"

        # rustup default stable

        echo "::group::install cargo-fuzz"
        cargo +nightly install cargo-fuzz
        # cargo install cargo-fuzz
        echo "::endgroup::"

        echo "::group::cargo clean"
        find . -name Cargo.toml -not -path "*-diff/*" -type f -exec dirname {} \; | xargs -t -I % cargo +nightly -C % clean
        # cargo clean || echo "cargo clean failed"
        [ -f Cargo.toml ] && cargo clean
        echo "::endgroup::"

    - name: Fuzz Demo
      if: ${{ github.event.inputs.submodule == 'humantime' }}
      run: |
        # cargo +nightly fuzz init

        # cat > fuzz/fuzz_targets/fuzz_target_1.rs << EOF
        # #![no_main]
        # use libfuzzer_sys::fuzz_target;
        # use humantime::{parse_duration, parse_rfc3339, parse_rfc3339_weak};
        # fuzz_target!(|data: &[u8]| {
        #     if let Ok(s) = std::str::from_utf8(data) {
        #         let _ = parse_duration(s);
        #         let _ = parse_rfc3339(s);
        #         let _ = parse_rfc3339_weak(s);
        #     }
        # });
        # EOF

        cd ..
        rm -rf humantime
        cargo new humantime
        cd humantime
        cargo +nightly fuzz init

        cat > fuzz/fuzz_targets/fuzz_target_1.rs << EOF
        #![no_main]
        use libfuzzer_sys::fuzz_target;
        pub fn pass_fuzzing(data: &[u8]) {
            let _ = data;
        }
        pub fn fail_fuzzing(data: &[u8]) {
            if data.len() == 7 {
                panic!("I'm afraid of number 7");
            }
        }
        fuzz_target!(|data: &[u8]| {
          let _ = pass_fuzzing(data);
          let _ = fail_fuzzing(data);
        });
        EOF

    # - if: matrix.rust == 'stable'
    #   run: rustup component add clippy
    # - if: matrix.os != 'windows-latest' && matrix.rust == 'stable'
    #   run: cargo clippy --all --all-features -- -D warnings

    # Build
    # - if: matrix.os != 'windows-latest'
    #   run: cargo build --verbose --all --all-features
    # - if: matrix.os == 'windows-latest'
    #   run: cargo build --verbose  --all --features __windows_ci_all
    # - run: cargo build --verbose --all

    # Test
    # - if: matrix.os != 'windows-latest'
    #   run: cargo test --verbose --all --all-features
    # - if: matrix.os == 'windows-latest'
    #   run: cargo test --verbose --all --features __windows_ci_all
    # - run: cargo test --verbose --all

    # - name: Checkout different tag
    #   if: matrix.tag != ''
    #   run: |
    #     git stash
    #     git fetch
    #     git stash pop
    #     git checkout tags/${{ matrix.tag }} -b ${{ matrix.tag }}
    #     git
    #     # git submodule update --init --recursive

    - name: Download archived Fuzzing Corpus, Artifacts and Coverage
      # if: ${{ github.event.inputs.resume_with_artifacts == 'true' }}
      if: ${{ env.ARTIFACT_DOWNLOAD == 'true' }}
      uses: actions/download-artifact@v3
      with:
        name: fuzzing-corpus-artifacts-coverage
        path: fuzz

    - name: Fuzzing
      id: fuzzing
      continue-on-error: true
      shell: bash
      run: |
        echo -e "pwd: $(pwd)\n"

        FUZZING_TARGET=${{ github.event.inputs.fuzz }}
        CORPUS_DIR=""
        CORPUS_DIR="fuzz/corpus/${{ github.event.inputs.fuzz }}"
        # SEED=0 # default: 0
        # SEED=1880631125 # default: 0
        SEED=${{ github.event.inputs.seed }}
        # ONLY_ASCII=1 # default: 0
        ONLY_ASCII=${{ github.event.inputs.only_ascii }}
        # MAX_TOTAL_TIME=$((60*60*6))
        MAX_TOTAL_TIME=${{ github.event.inputs.max_total_time }}
        if ${{ github.event.inputs.verbose == 'true' }}; then
          VERBOSE_1="-vv"
          VERBOSE_2="-v"
        else
          VERBOSE_1=""
          VERBOSE_2=""
        fi
        FUZZ_ARGS=${{ github.event.inputs.fuzz_args }}
        LOG_PATH=fuzz.log

        echo "::group::Copying corpus"
        # echo -e "\nCopying corpus..."
        mkdir -p $CORPUS_DIR
        cp --verbose ${{ github.event.inputs.corpus }} $CORPUS_DIR/
        echo "::endgroup::"

        echo -e "\nFuzzing with the following parameters:"
        # echo -e "\nREPO_NAME: $REPO_NAME\nWRITE_LOG: $WRITE_LOG\nLOG_PATH: $LOG_PATH\nFUZZING_TARGET: $FUZZING_TARGET\nCORPUS_DIR: $CORPUS_DIR\nSEED: $SEED\nONLY_ASCII: $ONLY_ASCII\nMAX_TOTAL_TIME: $MAX_TOTAL_TIME\n"
        echo -e "\nFUZZING_TARGET: $FUZZING_TARGET\nCORPUS_DIR: $CORPUS_DIR\nSEED: $SEED\nONLY_ASCII: $ONLY_ASCII\nMAX_TOTAL_TIME: $MAX_TOTAL_TIME\nVERBOSE: $VERBOSE_1\n"

        echo "::group::Fuzzing"
        # unbuffer cargo +nightly -C $REPO_NAME -vv --locked fuzz run -v $FUZZING_TARGET $CORPUS_DIR -- -only_ascii=$ONLY_ASCII -seed=$SEED -max_total_time=$MAX_TOTAL_TIME | tee -a $LOG_PATH
        # unbuffer cargo +nightly -vv --locked fuzz run -v $FUZZING_TARGET $CORPUS_DIR -- -only_ascii=$ONLY_ASCII -seed=$SEED -max_total_time=$MAX_TOTAL_TIME | tee -a $LOG_PATH
        # cargo +nightly -vv --locked fuzz run -v $FUZZING_TARGET $CORPUS_DIR -- -only_ascii=$ONLY_ASCII -seed=$SEED -max_total_time=$MAX_TOTAL_TIME
        # https://man7.org/linux/man-pages/man1/tee.1.html
        # https://manpages.ubuntu.com/manpages/jammy/en/man1/stdbuf.1.html
        cargo +nightly $VERBOSE_1 $FUZZ_ARGS fuzz run $VERBOSE_2 $FUZZING_TARGET $CORPUS_DIR -- -only_ascii=$ONLY_ASCII -seed=$SEED -max_total_time=$MAX_TOTAL_TIME -ignore_crashes=1 2>&1 | tee $LOG_PATH
        # cargo +nightly $VERBOSE_1 $FUZZ_ARGS fuzz run $VERBOSE_2 $FUZZING_TARGET $CORPUS_DIR -- -only_ascii=$ONLY_ASCII -seed=$SEED -max_total_time=$MAX_TOTAL_TIME -ignore_crashes=1 2>&1 | tee --output-error=warn-nopipe $LOG_PATH
        # unbuffer cargo +nightly $VERBOSE_1 $FUZZ_ARGS fuzz run $VERBOSE_2 $FUZZING_TARGET $CORPUS_DIR -- -only_ascii=$ONLY_ASCII -seed=$SEED -max_total_time=$MAX_TOTAL_TIME -ignore_crashes=1 | tee $LOG_PATH
        echo "::endgroup::"

    - name: Post Processing
      id: post-processing
      # if: ${{ steps.fuzzing.conclusion == 'success' }}
      # if: ${{ steps.fuzzing.outcome == 'success' }}
      # Possible values are success, failure, cancelled, or skipped.
      # When a continue-on-error step fails, the outcome is failure, but the final conclusion is success.
      continue-on-error: true
      run: |
        LOG_PATH=fuzz.log

        # echo "::group::playground"
        # apt update | tee -a $LOG_PATH
        # echo "::endgroup::"

        # echo "::group::Fuzzing Log"
        # echo "LOG_PATH: $LOG_PATH, $(realpath $LOG_PATH), $(dirname $(realpath $LOG_PATH))"
        # ls -lh
        # ls -lh $(dirname $(realpath $LOG_PATH))
        # [ -f $LOG_PATH ] && cat $LOG_PATH
        # echo "::endgroup::"

        echo "::group::Step Fuzzing Context"
        echo "conclusion:     ${{ steps.fuzzing.conclusion }}"
        echo "outcome:        ${{ steps.fuzzing.outcome }}"
        echo "outputs:        ${{ steps.fuzzing.outputs }}"
        echo "::endgroup::"

        # ARTIFACTS_DIR="fuzz/artifacts/${{ github.event.inputs.fuzz }}"
        # # is folder empty?
        # if [ -d $ARTIFACTS_DIR ] && [ ! -z "$(ls -A $ARTIFACTS_DIR)" ]; then
        #   echo -e "\t ARTIFACTS??? +++++++++++++++++++++++++++++++++++++++++++"
        # else
        #   echo -e "\t ARTIFACTS??? -------------------------------------------"
        # fi

        echo "::group::cat $LOG_PATH | grep INFO:"
        [ -f $LOG_PATH ] && echo "$LOG_PATH exists." || echo "$LOG_PATH does not exist."
        [ -f $LOG_PATH ] && wc -l $LOG_PATH
        # https://linuxcommand.org/lc3_man_pages/testh.html
        [ -s $LOG_PATH ] && cat $LOG_PATH | grep "INFO:"
        LOG_INFO="$(cat $LOG_PATH | grep "INFO:")"
        echo "LOG_INFO=$LOG_INFO" >> $GITHUB_OUTPUT
        # LOG_ERROR="$(tail -n "+$(grep -n 'NOTE:' $LOG_PATH | head -n 1 | cut -d ":" -f 1)" $LOG_PATH)"
        LOG_ERROR="$(tail -n "+$(($(grep -n 'NOTE:' $LOG_PATH | head -n 1 | cut -d ":" -f 1)+1))" $LOG_PATH)"
        echo "LOG_ERROR=$LOG_ERROR" >> $GITHUB_OUTPUT
        echo "::endgroup::"

        echo "::group::Summary"
        FOUND_ARTIFACTS=($(find fuzz/artifacts -type f))
        # bla1=($(find docs/gh-actions/runs4272680831jobs7438036693 -type f))
        # bla1=($(find docs/gh-actions -type f))

        if [ ${#FOUND_ARTIFACTS[@]} -ne 0 ]; then
          echo "## Errors found" >> $GITHUB_STEP_SUMMARY
          for x in ${FOUND_ARTIFACTS[@]}; do
            {
              echo "### $x"
              echo "Error occurred with the following input:"
              echo ""
              echo "```"
            } >> $GITHUB_STEP_SUMMARY
            cat $x >> $GITHUB_STEP_SUMMARY
            {
              echo "```"
              echo ""
            } >> $GITHUB_STEP_SUMMARY
            crash_file="$(cat $x)"
            echo "ERROR_INPUT=$crash_file" >> $GITHUB_OUTPUT
          done
        else
          echo "## Success" >> $GITHUB_STEP_SUMMARY
          echo "No errors found." >> $GITHUB_STEP_SUMMARY
        fi
        echo "::endgroup::"

        echo "GITHUB_STEP_SUMMARY=$GITHUB_STEP_SUMMARY" >> $GITHUB_OUTPUT

    - name: Fuzzing Finished
      run: |
        echo -e "\n\nFuzzing finished.\n"
        echo "::group::ls"
        ls -lha
        echo "::endgroup::"

        echo "::group::ls fuzz"
        ls -lha fuzz
        echo "::endgroup::"

        echo "::group::ls fuzz/artifacts"
        ls -lha fuzz/artifacts
        echo "::endgroup::"
        echo "::group::ls fuzz/artifacts/${{ github.event.inputs.fuzz }}"
        ls -lha fuzz/artifacts/${{ github.event.inputs.fuzz }}
        echo
        find fuzz/artifacts -type f
        echo "::endgroup::"

        echo "::group::ls fuzz/corpus"
        ls -lha fuzz/corpus
        echo "::endgroup::"
        echo "::group::ls fuzz/corpus/${{ github.event.inputs.fuzz }}"
        ls -lha fuzz/corpus/${{ github.event.inputs.fuzz }} | head -n 20
        echo "::endgroup::"

        echo "::group::du"
        du -h -d 3 . | sort -h
        echo "::endgroup::"

        # echo "::group::Cargo.lock"
        # [ -f Cargo.lock ] && cat Cargo.lock
        # echo "::endgroup::"

        # echo "::group::fuzz/Cargo.lock"
        # cat fuzz/Cargo.lock
        # echo "::endgroup::"

    - name: ls repo
      run: |
        echo "::group::ls repo"
        find . -print | sed -e "s;[^/]*/;|____;g;s;____|;  |;g"
        echo "::endgroup::"

        # echo "::group::ls parent repo"
        # find .. -print | sed -e "s;[^/]*/;|____;g;s;____|;  |;g"
        # echo "::endgroup::"

    # - name: ls parent repo
    #   run: |
    #     find .. -print | sed -e "s;[^/]*/;|____;g;s;____|;  |;g"

    - name: Archive Fuzzing Corpus, Artifacts and Coverage
      # if: ${{ github.event.inputs.upload_artifacts == 'true' }}
      if: ${{ env.ARTIFACT_UPLOAD == 'true' }}
      uses: actions/upload-artifact@v3
      with:
        # name: fuzzing-corpus-artifacts-coverage-${{ github.event.inputs.submodule }}
        name: fuzzing-corpus-artifacts-coverage
        # retention-days: 90
        path: |
          ${{ github.event.inputs.submodule }}/fuzz/corpus
          ${{ github.event.inputs.submodule }}/fuzz/artifacts
          ${{ github.event.inputs.submodule }}/fuzz/coverage
          # !fuzz/fuzz_targets
          # !fuzz/target
          # !dist/**/*.md
      # working-directory: ${{ github.event.inputs.submodule }}

    - name: Create new issue
      continue-on-error: true
      # https://docs.github.com/en/actions/using-workflows/using-github-cli-in-workflows
      # https://docs.github.com/en/actions/examples/using-the-github-cli-on-a-runner
      # # https://github.com/marketplace/actions/issues-helper
      # # https://github.com/marketplace/actions/create-an-issue
      # uses: JasonEtco/create-an-issue@v2
      # https://github.com/marketplace/actions/issue-bot-action
      # https://docs.github.com/en/actions/managing-issues-and-pull-requests/scheduling-issue-creation
      uses: imjohnbo/issue-bot@v3
      # Possible values are success, failure, cancelled, or skipped.
      # When a continue-on-error step fails, the outcome is failure, but the final conclusion is success.
      # if: ${{ steps.fuzzing.outcome == 'DONTRUN' }}
      if: ${{ steps.fuzzing.outcome == 'failure' }}
      # if: failure()
      with:
        # assignees: "octocat, monalisa"
        title: Error found while fuzzing ${{ github.event.inputs.fuzz }} in ${{ github.event.inputs.submodule }}
        labels: "bug, fuzzing, ci"
        body: |-
          Fuzz log | grep "INFO:"

          ```
          ${{ steps.post-processing.outputs.LOG_INFO }}
          ```

          Error:

          ```
          ${{ steps.post-processing.outputs.LOG_ERROR }}
          ```

error_file         Error occured with the following input:

          ```
crash         ${{ steps.postyprocessing.outputs.ERROR_INPUT }}
          crash
crash          ${{ steps.post-processing.outputs.GITHUB_STEP_SUMMARY }}
        # body: |-
        #   # :wave: Hi, {{#each assignees}}@{{this}}{{#unless @last}}, {{/unless}}{{/each}}!

        # pinned: true
      # env:
      #   GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      #   ISSUE: ${{ github.event.issue.html_url }}
      # run: gh issue comment $ISSUE --body "Thank you for opening this issue!"

# bin/act workflow_dispatch -j fuzz --input max_total_time=30 --input fuzz=fuzz_target_rrdp --input submodule=rpki-rs --input resume_with_artifacts=true | batcat
# bin/act workflow_dispatch -j fuzz --input submodule=rpki-rs --input fuzz=fuzz_target_rrdp --input max_total_time=30 --input seed=0 --input only_ascii=1 --input corpus="../corpus/xml/snapshot/*" --input resume_with_artifacts=false --input upload_artifacts=false --input rust_toolchain=nightly --input verbose=false | batcat
# bin/act workflow_dispatch -j fuzz --input submodule=rpki-rs --input fuzz=fuzz_target_rrdp --input max_total_time=30 --input seed=0 --input only_ascii=1 --input corpus="../corpus/xml/snapshot/*" --input fuzz_args="--locked" --input artifacts_up_down_load=none --input rust_toolchain=nightly --input verbose=false | batcat
# bin/act workflow_dispatch -j fuzz --input submodule=rpki-rs --input fuzz=fuzz_target_1 --input max_total_time=300 --input seed=0 --input only_ascii=1 --input corpus="../corpus/all/*" --input fuzz_args="--locked" --input artifacts_up_down_load=none --input rust_toolchain=nightly --input verbose=false --env GITHUB_STEP_SUMMARY="/dev/stdout" | batcat

# bin/act workflow_dispatch -j fuzz --input submodule=humantime --input fuzz=fuzz_target_1 --input max_total_time=300 --input seed=0 --input only_ascii=1 --input corpus="../corpus/all/*" --input fuzz_args="--locked" --input artifacts_up_down_load=none --input rust_toolchain=nightly --input verbose=false | batcat

# bin/act workflow_dispatch -j fuzz --input submodule=rpki-rs --input fuzz=fuzz_target_rrdp --input max_total_time=30 --input seed=0 --input only_ascii=1 --input corpus="../docs/gh-actions/snapshot/*" --input fuzz_args="--locked" --input artifacts_up_down_load=none --input rust_toolchain=nightly --input verbose=false | batcat
